Challenge 2 Report - Sebastian Wisniowiecki, Caitlin Wang

1. Results table

+----------------------+-------------------------+
| Allocator, test file | Measured time (seconds) |
+----------------------+-------------------------+
| hw07, ivec           |                    0.05 |
| hw07, list           |                    0.05 |
| par, ivec            |                    0.05 |
| par, list            |                    0.05 |
| sys, ivec            |                    0.05 |
| sys, list            |                    0.05 |
+----------------------+-------------------------+


2. Test machine specs

Local machine:

Operating system: Linux Ubuntu (64-bit)
Processor model: Intel Core i5-4278U CPU @ 2.60GHz 
Number of processor cores: 2
Amount of RAM: 2GB


3. Strategy discussion

We attempted to implement the following strategies to optimize our
allocator from Homework 8:

Simple bucket allocator:
We started off by implementing a bucket allocator in order to 
reduce the time it takes to find an available chunk of memory. Using
a bitmap, we are now able to lookup a free chunk in constant time.

Multiple arenas:
We then decided to implement multiple arenas as an optimized approach
to making our allocator thread-safe. In our program, each arena is a
separate copy of our list of buckets. With our hw07_malloc allocator
we simply instantiated a global mutex and locked it whenever our
free list was being accessed/modified. However, we wanted to avoid
lock contention so we initialized a mutex for each arena.

Unmapping empty buckets:

Allocating > 1 page per bucket:
This is something we worked on but were ultimately unable to
completely implement.


4. Results discussion


